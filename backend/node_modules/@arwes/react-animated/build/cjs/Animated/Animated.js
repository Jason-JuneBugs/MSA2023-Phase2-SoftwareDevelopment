"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Animated = void 0;
const react_1 = require("react");
const motion_1 = require("motion");
const react_tools_1 = require("@arwes/react-tools");
const animator_1 = require("@arwes/animator");
const react_animator_1 = require("@arwes/react-animator");
const index_1 = require("../internal/formatAnimatedCSSPropsShorthands/index");
const Animated = (props) => {
    const { as: asProvided, animated, className, style, elementRef: externalElementRef, hideOnExited = true, hideOnEntered, ...otherProps } = props;
    const animator = (0, react_animator_1.useAnimator)();
    const as = (0, react_1.useMemo)(() => asProvided || 'div', []);
    const elementRef = (0, react_1.useRef)(null);
    const animatedSettingsRef = (0, react_1.useRef)([]);
    const animationControlsRef = (0, react_1.useRef)([]);
    const [isExited, setIsExited] = (0, react_1.useState)(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === animator_1.ANIMATOR_STATES.exited);
    const [isEntered, setIsEntered] = (0, react_1.useState)(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === animator_1.ANIMATOR_STATES.entered);
    const animatedSettingsListReceived = Array.isArray(animated) ? animated : [animated];
    const animatedSettingsList = animatedSettingsListReceived.filter(Boolean);
    // The animations list is passed as a reference so the Animator node subscription
    // and its respective functionalities are only initialized once for performance.
    animatedSettingsRef.current = animatedSettingsList;
    (0, react_1.useEffect)(() => {
        if (!animator) {
            return;
        }
        const cancelSubscription = animator.node.subscribe(node => {
            setIsExited(node.state === animator_1.ANIMATOR_STATES.exited);
            setIsEntered(node.state === animator_1.ANIMATOR_STATES.entered);
            animationControlsRef.current = [];
            const element = elementRef.current;
            // Weird case if the element is removed and the subscription is not cancelled.
            if (!element) {
                return;
            }
            const settingsList = animatedSettingsRef.current;
            const { duration } = node;
            const durationTransition = node.state === animator_1.ANIMATOR_STATES.entering || node.state === animator_1.ANIMATOR_STATES.entered
                ? duration.enter
                : duration.exit;
            settingsList
                .map(settingsItem => { var _a; return (_a = settingsItem.transitions) === null || _a === void 0 ? void 0 : _a[node.state]; })
                .filter(Boolean)
                .map(transitions => Array.isArray(transitions) ? transitions : [transitions])
                .flat(1)
                .forEach(transition => {
                if (typeof transition === 'function') {
                    const control = transition({
                        element,
                        duration: durationTransition
                    });
                    if (control) {
                        animationControlsRef.current.push(control);
                    }
                }
                else {
                    const { duration, delay, easing, options, ...definition } = transition;
                    const control = (0, motion_1.animate)(element, definition, { duration: duration || durationTransition, delay, easing, ...options });
                    animationControlsRef.current.push(control);
                }
            });
        });
        return () => {
            cancelSubscription();
            animationControlsRef.current.forEach(control => control.stop());
        };
    }, [animator]);
    let initialAttributes;
    if (animator) {
        // TODO: Fix type.
        initialAttributes = animatedSettingsList
            .map(item => item === null || item === void 0 ? void 0 : item.initialAttributes)
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    let dynamicStyles;
    if (animator) {
        dynamicStyles = animatedSettingsList
            .map(item => (0, index_1.formatAnimatedCSSPropsShorthands)(item === null || item === void 0 ? void 0 : item.initialStyle))
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    return (0, react_1.createElement)(as, {
        ...otherProps,
        ...initialAttributes,
        className,
        style: {
            ...style,
            ...dynamicStyles,
            visibility: animator && ((hideOnExited && isExited) || (hideOnEntered && isEntered)) ? 'hidden' : 'visible'
        },
        ref: (0, react_tools_1.mergeRefs)(externalElementRef, elementRef)
    });
};
exports.Animated = Animated;
