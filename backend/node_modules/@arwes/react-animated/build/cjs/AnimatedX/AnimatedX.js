"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimatedX = void 0;
const react_1 = require("react");
const motion_1 = require("motion");
const react_tools_1 = require("@arwes/react-tools");
const index_1 = require("../internal/formatAnimatedCSSPropsShorthands/index");
const AnimatedX = (props) => {
    const { as: asProvided, state: animatedState, animated, className, style, elementRef: externalElementRef, ...otherProps } = props;
    const hasState = animatedState !== undefined && animatedState !== null;
    const as = (0, react_1.useMemo)(() => asProvided || 'div', []);
    const elementRef = (0, react_1.useRef)(null);
    const animatedSettingsRef = (0, react_1.useRef)([]);
    const animationControlsRef = (0, react_1.useRef)([]);
    const animatedSettingsListReceived = Array.isArray(animated) ? animated : [animated];
    const animatedSettingsList = animatedSettingsListReceived.filter(Boolean);
    // The animations list is passed as a reference so the Animator node subscription
    // and its respective functionalities are only initialized once for performance.
    animatedSettingsRef.current = animatedSettingsList;
    (0, react_1.useEffect)(() => {
        if (!hasState) {
            return;
        }
        animationControlsRef.current = [];
        const element = elementRef.current;
        const settingsList = animatedSettingsRef.current;
        // Weird case if the element is removed and the subscription is not cancelled.
        if (!element) {
            return;
        }
        settingsList
            .map(settingsItem => { var _a; return (_a = settingsItem.transitions) === null || _a === void 0 ? void 0 : _a[animatedState]; })
            .filter(Boolean)
            .map(transitions => Array.isArray(transitions) ? transitions : [transitions])
            .flat(1)
            .forEach(transition => {
            if (typeof transition === 'function') {
                const control = transition({ element, duration: 0 });
                if (control) {
                    animationControlsRef.current.push(control);
                }
            }
            else {
                const { duration, delay, easing, options, ...definition } = transition;
                const control = (0, motion_1.animate)(element, definition, { duration, delay, easing, ...options });
                animationControlsRef.current.push(control);
            }
        });
        return () => {
            animationControlsRef.current.forEach(control => control.stop());
        };
    }, [hasState, animatedState]);
    let initialAttributes;
    if (hasState) {
        // TODO: Fix type.
        initialAttributes = animatedSettingsList
            .map(item => item === null || item === void 0 ? void 0 : item.initialAttributes)
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    let dynamicStyles;
    if (hasState) {
        dynamicStyles = animatedSettingsList
            .map(item => (0, index_1.formatAnimatedCSSPropsShorthands)(item === null || item === void 0 ? void 0 : item.initialStyle))
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    return (0, react_1.createElement)(as, {
        ...otherProps,
        ...initialAttributes,
        className,
        style: {
            ...style,
            ...dynamicStyles
        },
        ref: (0, react_tools_1.mergeRefs)(externalElementRef, elementRef)
    });
};
exports.AnimatedX = AnimatedX;
