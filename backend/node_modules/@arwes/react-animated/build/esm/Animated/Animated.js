import { createElement, useRef, useMemo, useState, useEffect } from 'react';
import { animate } from 'motion';
import { mergeRefs } from '@arwes/react-tools';
import { ANIMATOR_STATES as STATES } from '@arwes/animator';
import { useAnimator } from '@arwes/react-animator';
import { formatAnimatedCSSPropsShorthands } from "../internal/formatAnimatedCSSPropsShorthands/index.js";
const Animated = (props) => {
    const { as: asProvided, animated, className, style, elementRef: externalElementRef, hideOnExited = true, hideOnEntered, ...otherProps } = props;
    const animator = useAnimator();
    const as = useMemo(() => asProvided || 'div', []);
    const elementRef = useRef(null);
    const animatedSettingsRef = useRef([]);
    const animationControlsRef = useRef([]);
    const [isExited, setIsExited] = useState(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === STATES.exited);
    const [isEntered, setIsEntered] = useState(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === STATES.entered);
    const animatedSettingsListReceived = Array.isArray(animated) ? animated : [animated];
    const animatedSettingsList = animatedSettingsListReceived.filter(Boolean);
    // The animations list is passed as a reference so the Animator node subscription
    // and its respective functionalities are only initialized once for performance.
    animatedSettingsRef.current = animatedSettingsList;
    useEffect(() => {
        if (!animator) {
            return;
        }
        const cancelSubscription = animator.node.subscribe(node => {
            setIsExited(node.state === STATES.exited);
            setIsEntered(node.state === STATES.entered);
            animationControlsRef.current = [];
            const element = elementRef.current;
            // Weird case if the element is removed and the subscription is not cancelled.
            if (!element) {
                return;
            }
            const settingsList = animatedSettingsRef.current;
            const { duration } = node;
            const durationTransition = node.state === STATES.entering || node.state === STATES.entered
                ? duration.enter
                : duration.exit;
            settingsList
                .map(settingsItem => { var _a; return (_a = settingsItem.transitions) === null || _a === void 0 ? void 0 : _a[node.state]; })
                .filter(Boolean)
                .map(transitions => Array.isArray(transitions) ? transitions : [transitions])
                .flat(1)
                .forEach(transition => {
                if (typeof transition === 'function') {
                    const control = transition({
                        element,
                        duration: durationTransition
                    });
                    if (control) {
                        animationControlsRef.current.push(control);
                    }
                }
                else {
                    const { duration, delay, easing, options, ...definition } = transition;
                    const control = animate(element, definition, { duration: duration || durationTransition, delay, easing, ...options });
                    animationControlsRef.current.push(control);
                }
            });
        });
        return () => {
            cancelSubscription();
            animationControlsRef.current.forEach(control => control.stop());
        };
    }, [animator]);
    let initialAttributes;
    if (animator) {
        // TODO: Fix type.
        initialAttributes = animatedSettingsList
            .map(item => item === null || item === void 0 ? void 0 : item.initialAttributes)
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    let dynamicStyles;
    if (animator) {
        dynamicStyles = animatedSettingsList
            .map(item => formatAnimatedCSSPropsShorthands(item === null || item === void 0 ? void 0 : item.initialStyle))
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    return createElement(as, {
        ...otherProps,
        ...initialAttributes,
        className,
        style: {
            ...style,
            ...dynamicStyles,
            visibility: animator && ((hideOnExited && isExited) || (hideOnEntered && isEntered)) ? 'hidden' : 'visible'
        },
        ref: mergeRefs(externalElementRef, elementRef)
    });
};
export { Animated };
