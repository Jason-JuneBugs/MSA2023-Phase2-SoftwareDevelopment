import { createElement, useRef, useMemo, useEffect } from 'react';
import { animate } from 'motion';
import { mergeRefs } from '@arwes/react-tools';
import { formatAnimatedCSSPropsShorthands } from "../internal/formatAnimatedCSSPropsShorthands/index.js";
const AnimatedX = (props) => {
    const { as: asProvided, state: animatedState, animated, className, style, elementRef: externalElementRef, ...otherProps } = props;
    const hasState = animatedState !== undefined && animatedState !== null;
    const as = useMemo(() => asProvided || 'div', []);
    const elementRef = useRef(null);
    const animatedSettingsRef = useRef([]);
    const animationControlsRef = useRef([]);
    const animatedSettingsListReceived = Array.isArray(animated) ? animated : [animated];
    const animatedSettingsList = animatedSettingsListReceived.filter(Boolean);
    // The animations list is passed as a reference so the Animator node subscription
    // and its respective functionalities are only initialized once for performance.
    animatedSettingsRef.current = animatedSettingsList;
    useEffect(() => {
        if (!hasState) {
            return;
        }
        animationControlsRef.current = [];
        const element = elementRef.current;
        const settingsList = animatedSettingsRef.current;
        // Weird case if the element is removed and the subscription is not cancelled.
        if (!element) {
            return;
        }
        settingsList
            .map(settingsItem => { var _a; return (_a = settingsItem.transitions) === null || _a === void 0 ? void 0 : _a[animatedState]; })
            .filter(Boolean)
            .map(transitions => Array.isArray(transitions) ? transitions : [transitions])
            .flat(1)
            .forEach(transition => {
            if (typeof transition === 'function') {
                const control = transition({ element, duration: 0 });
                if (control) {
                    animationControlsRef.current.push(control);
                }
            }
            else {
                const { duration, delay, easing, options, ...definition } = transition;
                const control = animate(element, definition, { duration, delay, easing, ...options });
                animationControlsRef.current.push(control);
            }
        });
        return () => {
            animationControlsRef.current.forEach(control => control.stop());
        };
    }, [hasState, animatedState]);
    let initialAttributes;
    if (hasState) {
        // TODO: Fix type.
        initialAttributes = animatedSettingsList
            .map(item => item === null || item === void 0 ? void 0 : item.initialAttributes)
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    let dynamicStyles;
    if (hasState) {
        dynamicStyles = animatedSettingsList
            .map(item => formatAnimatedCSSPropsShorthands(item === null || item === void 0 ? void 0 : item.initialStyle))
            .reduce((total, item) => ({ ...total, ...item }), {});
    }
    return createElement(as, {
        ...otherProps,
        ...initialAttributes,
        className,
        style: {
            ...style,
            ...dynamicStyles
        },
        ref: mergeRefs(externalElementRef, elementRef)
    });
};
export { AnimatedX };
