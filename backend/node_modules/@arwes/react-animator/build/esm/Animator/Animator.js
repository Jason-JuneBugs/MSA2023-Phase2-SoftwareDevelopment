import { createElement, useMemo, useContext, useRef, useEffect, useState } from 'react';
import { ANIMATOR_DEFAULT_SETTINGS, ANIMATOR_STATES as STATES, ANIMATOR_ACTIONS as ACTIONS, createAnimatorSystem } from '@arwes/animator';
import { AnimatorContext } from "../internal/AnimatorContext/index.js";
import { AnimatorGeneralContext } from "../internal/AnimatorGeneralContext/index.js";
const setNodeRefValue = (nodeRef, node) => {
    if (typeof nodeRef === 'function') {
        nodeRef(node);
    }
    else if (nodeRef) {
        nodeRef.current = node;
    }
};
const Animator = (props) => {
    // It is responsibility of the <Animator> to register, setup, update, and unregister
    // the new node every time there is a change in it, since they happen on UI events.
    const { root, disabled, dismissed, unmountOnExited, unmountOnEntered, unmountOnDisabled, checkToSendAction, checkToSend, nodeRef, children, ...settings } = props;
    const parentAnimatorInterface = useContext(AnimatorContext);
    const animatorGeneralInterface = useContext(AnimatorGeneralContext);
    const settingsRef = useRef(settings);
    const dynamicSettingsRef = useRef(null);
    const foreignRef = useRef(null);
    const prevAnimatorRef = useRef(undefined);
    const isFirstRender1Ref = useRef(true);
    const isFirstRender2Ref = useRef(true);
    settingsRef.current = settings;
    const animatorGeneralSettings = animatorGeneralInterface === null || animatorGeneralInterface === void 0 ? void 0 : animatorGeneralInterface.getSettings();
    const isRoot = !!root || !parentAnimatorInterface;
    const isDismissed = dismissed !== undefined ? !!dismissed : !!(animatorGeneralSettings === null || animatorGeneralSettings === void 0 ? void 0 : animatorGeneralSettings.dismissed);
    const isDisabled = disabled !== undefined ? !!disabled : !!(animatorGeneralSettings === null || animatorGeneralSettings === void 0 ? void 0 : animatorGeneralSettings.disabled);
    const animatorInterface = useMemo(() => {
        if (prevAnimatorRef.current) {
            prevAnimatorRef.current.system.unregister(prevAnimatorRef.current.node);
        }
        if (isDismissed) {
            setNodeRefValue(nodeRef, null);
            return parentAnimatorInterface;
        }
        if (isDisabled) {
            setNodeRefValue(nodeRef, null);
            return undefined;
        }
        const system = isRoot
            ? createAnimatorSystem()
            : parentAnimatorInterface.system;
        const getSettings = () => {
            var _a, _b;
            const animatorGeneralSettings = animatorGeneralInterface === null || animatorGeneralInterface === void 0 ? void 0 : animatorGeneralInterface.getSettings();
            return {
                ...ANIMATOR_DEFAULT_SETTINGS,
                ...animatorGeneralSettings,
                ...settingsRef.current,
                ...dynamicSettingsRef.current,
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                duration: {
                    ...ANIMATOR_DEFAULT_SETTINGS.duration,
                    ...animatorGeneralSettings === null || animatorGeneralSettings === void 0 ? void 0 : animatorGeneralSettings.duration,
                    ...(_a = settingsRef.current) === null || _a === void 0 ? void 0 : _a.duration,
                    ...(_b = dynamicSettingsRef.current) === null || _b === void 0 ? void 0 : _b.duration
                },
                onTransition: (node) => {
                    var _a, _b, _c, _d;
                    (_b = (_a = settingsRef.current) === null || _a === void 0 ? void 0 : _a.onTransition) === null || _b === void 0 ? void 0 : _b.call(_a, node);
                    (_d = (_c = dynamicSettingsRef.current) === null || _c === void 0 ? void 0 : _c.onTransition) === null || _d === void 0 ? void 0 : _d.call(_c, node);
                }
            };
        };
        const setDynamicSettings = (newSettings) => {
            dynamicSettingsRef.current = newSettings;
        };
        const getDynamicSettings = () => {
            return dynamicSettingsRef.current;
        };
        const getForeignRef = () => {
            return foreignRef.current;
        };
        const setForeignRef = (ref) => {
            foreignRef.current = ref;
        };
        const control = Object.freeze({
            getSettings,
            setDynamicSettings,
            getDynamicSettings,
            getForeignRef,
            setForeignRef
        });
        const node = isRoot
            ? system.register(undefined, control)
            : system.register(parentAnimatorInterface.node, control);
        setNodeRefValue(nodeRef, node);
        return Object.freeze({ system, node });
    }, [parentAnimatorInterface, isRoot, isDisabled, isDismissed]);
    prevAnimatorRef.current = animatorInterface;
    const [isEnabledToUnmount, setIsEnabledToUnmount] = useState(() => (unmountOnExited && (animatorInterface === null || animatorInterface === void 0 ? void 0 : animatorInterface.node.state) === STATES.exited) ||
        (unmountOnEntered && (animatorInterface === null || animatorInterface === void 0 ? void 0 : animatorInterface.node.state) === STATES.entered) ||
        (unmountOnDisabled && isDisabled));
    useEffect(() => {
        return () => {
            if (prevAnimatorRef.current) {
                prevAnimatorRef.current.system.unregister(prevAnimatorRef.current.node);
            }
        };
    }, []);
    // Setup on mounted and in case animator is disabled and then re-enabled,
    // trigger the setup once is created again.
    useEffect(() => {
        animatorInterface === null || animatorInterface === void 0 ? void 0 : animatorInterface.node.send(ACTIONS.setup);
    }, [!!animatorInterface]);
    // Trigger updates on animator only after first render, since in the first render
    // the setup event would take care of the initial data procedore.
    useEffect(() => {
        if (isFirstRender1Ref.current) {
            isFirstRender1Ref.current = false;
            return;
        }
        animatorInterface === null || animatorInterface === void 0 ? void 0 : animatorInterface.node.send(ACTIONS.update);
    }, [settings.active, settings.manager, settings.merge, settings.combine]);
    useEffect(() => {
        if (animatorInterface) {
            const cancelSubscription = animatorInterface.node.subscribe(node => {
                setIsEnabledToUnmount((unmountOnExited && node.state === STATES.exited) ||
                    (unmountOnEntered && node.state === STATES.entered));
            });
            return () => cancelSubscription();
        }
        else {
            setIsEnabledToUnmount(unmountOnDisabled);
        }
    }, [animatorInterface, unmountOnExited, unmountOnEntered, unmountOnDisabled]);
    useEffect(() => {
        if (isFirstRender2Ref.current) {
            isFirstRender2Ref.current = false;
            return;
        }
        if (animatorInterface) {
            animatorInterface.node.send(checkToSendAction !== null && checkToSendAction !== void 0 ? checkToSendAction : ACTIONS.refresh);
        }
    }, checkToSend !== null && checkToSend !== void 0 ? checkToSend : []);
    return createElement(AnimatorContext.Provider, { value: animatorInterface }, isEnabledToUnmount ? null : children);
};
export { Animator };
