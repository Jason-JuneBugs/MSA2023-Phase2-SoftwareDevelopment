"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Puffs = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importStar(require("react"));
const motion_1 = require("motion");
const tools_1 = require("@arwes/tools");
const react_tools_1 = require("@arwes/react-tools");
const animated_1 = require("@arwes/animated");
const animator_1 = require("@arwes/animator");
const react_animator_1 = require("@arwes/react-animator");
const { entering, entered, exiting, exited } = animator_1.ANIMATOR_STATES;
const minmaxOverflow01 = (value) => Math.min(1, Math.max(0, value === 1 ? 1 : value % 1));
const defaultProps = {
    padding: 50,
    xOffset: [0, 0],
    yOffset: [-10, -100],
    radiusInitial: 4,
    radiusOffset: [4, 40],
    sets: 5
};
const Puffs = (props) => {
    const propsFull = { ...defaultProps, ...props };
    const { elementRef: elementRefExternal, className, style } = propsFull;
    const animator = (0, react_animator_1.useAnimator)();
    const elementRef = (0, react_1.useRef)(null);
    const propsFullRef = (0, react_1.useRef)(propsFull);
    propsFullRef.current = propsFull;
    (0, react_1.useEffect)(() => {
        if (!animator) {
            return;
        }
        const canvas = elementRef.current;
        const ctx = canvas.getContext('2d');
        let canvasControl;
        let puffsControl;
        let puffsEmptyTimeoutId;
        const cancelAnimationSubscriptions = () => {
            canvasControl === null || canvasControl === void 0 ? void 0 : canvasControl.cancel();
            puffsControl === null || puffsControl === void 0 ? void 0 : puffsControl.cancel();
            window.clearTimeout(puffsEmptyTimeoutId);
        };
        const animatorSubscription = (node) => {
            const state = node.state;
            const { duration } = node.control.getSettings();
            switch (state) {
                case entering: {
                    cancelAnimationSubscriptions();
                    const { color, quantity, padding, xOffset, yOffset, radiusInitial, radiusOffset, sets } = propsFullRef.current;
                    const puffsSetQuantity = Math.round(quantity / sets);
                    const puffsSetOffset = 1 / sets;
                    const createPuff = (width, height) => {
                        const x = padding + (Math.random() * (width - (padding * 2)));
                        const y = padding + (Math.random() * (height - (padding * 2)));
                        const r = radiusInitial;
                        const xo = xOffset[0] + (Math.random() * xOffset[1]);
                        const yo = yOffset[0] + (Math.random() * yOffset[1]);
                        const ro = radiusOffset[0] + (Math.random() * radiusOffset[1]);
                        return { x, y, r, xo, yo, ro };
                    };
                    const createPuffsSets = (width, height) => {
                        return Array(sets)
                            .fill(null)
                            .map(() => Array(puffsSetQuantity)
                            .fill(null)
                            .map(() => createPuff(width, height)));
                    };
                    const drawPuffs = (puffs, progress) => {
                        // From: 0 at 0%, 1 at 50%, 0 at 100%.
                        ctx.globalAlpha = progress <= 0.5
                            ? progress * 2
                            : -2 * progress + 2;
                        puffs.forEach(puff => {
                            const x = puff.x + (progress * puff.xo);
                            const y = puff.y + (progress * puff.yo);
                            const r = puff.r + (progress * puff.ro);
                            const grd = ctx.createRadialGradient(x, y, 0, x, y, r);
                            grd.addColorStop(0, color);
                            grd.addColorStop(1, 'transparent');
                            ctx.beginPath();
                            ctx.fillStyle = grd;
                            ctx.arc(x, y, r, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.closePath();
                        });
                    };
                    let puffsSets = [];
                    const draw = (intervalProgress) => {
                        const width = canvas.clientWidth;
                        const height = canvas.clientHeight;
                        const isResized = canvas.width !== width || canvas.height !== height;
                        if (isResized || !puffsSets.length) {
                            puffsSets = createPuffsSets(width, height);
                        }
                        canvas.width = width;
                        canvas.height = height;
                        ctx.clearRect(0, 0, width, height);
                        puffsSets.forEach((puffs, index) => {
                            const puffsOffset = puffsSetOffset * index;
                            const puffsProgress = minmaxOverflow01(intervalProgress + puffsOffset);
                            drawPuffs(puffs, animated_1.easing.outSine(puffsProgress));
                        });
                    };
                    canvasControl = (0, motion_1.animate)(canvas, { opacity: [0, 1] }, { duration: duration === null || duration === void 0 ? void 0 : duration.enter });
                    const runPuffsAnimation = () => {
                        puffsControl = (0, motion_1.animate)((progress) => {
                            draw(progress);
                            if (progress >= 1) {
                                const emptyDuration = ((duration === null || duration === void 0 ? void 0 : duration.intervalPause) || 0) * 1000;
                                window.clearTimeout(puffsEmptyTimeoutId);
                                window.setTimeout(runPuffsAnimation, emptyDuration);
                            }
                        }, { duration: duration === null || duration === void 0 ? void 0 : duration.interval, easing: 'linear' });
                    };
                    runPuffsAnimation();
                    break;
                }
                case entered: {
                    break;
                }
                case exiting: {
                    canvasControl === null || canvasControl === void 0 ? void 0 : canvasControl.cancel();
                    canvasControl = (0, motion_1.animate)(canvas, { opacity: [1, 0] }, { duration: duration === null || duration === void 0 ? void 0 : duration.exit });
                    break;
                }
                case exited: {
                    cancelAnimationSubscriptions();
                    canvas.style.opacity = '0';
                    break;
                }
            }
        };
        animator.node.subscribers.add(animatorSubscription);
        return () => {
            animator.node.subscribers.delete(animatorSubscription);
            cancelAnimationSubscriptions();
        };
    }, [animator]);
    return (react_1.default.createElement("canvas", { role: 'presentation', ref: (0, react_tools_1.mergeRefs)(elementRef, elementRefExternal), className: (0, tools_1.cx)('arwes-react-bgs-puffs', className), style: {
            position: 'absolute',
            left: 0,
            top: 0,
            display: 'block',
            border: 0,
            margin: 0,
            padding: 0,
            width: '100%',
            height: '100%',
            ...style
        } }));
};
exports.Puffs = Puffs;
