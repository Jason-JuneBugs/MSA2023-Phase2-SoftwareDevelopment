"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFrameSVGAssemblingAnimation = void 0;
const react_1 = require("react");
const motion_1 = require("motion");
const animator_1 = require("@arwes/animator");
const react_animator_1 = require("@arwes/react-animator");
const useFrameSVGAssemblingAnimation = (svgRef) => {
    const animator = (0, react_animator_1.useAnimator)();
    const animationControlRef = (0, react_1.useRef)(null);
    (0, react_1.useEffect)(() => {
        const svg = svgRef.current;
        if (!svg) {
            return;
        }
        const bgs = Array.from(svg.querySelectorAll('[data-name=bg]'));
        const lines = Array.from(svg.querySelectorAll('[data-name=line]'));
        bgs.concat(lines).forEach(path => {
            path.style.opacity = '1';
            path.style.strokeDasharray = '';
            path.style.strokeDashoffset = '';
        });
        if (!animator) {
            return;
        }
        const unsubscribe = animator.node.subscribe(node => {
            var _a;
            const { duration } = node;
            (_a = animationControlRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
            switch (node.state) {
                case 'exited': {
                    bgs.concat(lines).forEach(path => {
                        path.style.opacity = '0';
                        path.style.strokeDasharray = '';
                        path.style.strokeDashoffset = '';
                    });
                    break;
                }
                case 'entering': {
                    for (const polyline of lines) {
                        const length = polyline.getTotalLength();
                        polyline.style.opacity = '1';
                        polyline.style.strokeDasharray = String(length);
                        polyline.dataset.length = String(length);
                    }
                    animationControlRef.current = (0, motion_1.animate)(progress => {
                        for (const shape of bgs) {
                            shape.style.opacity = String(progress);
                        }
                        for (const polyline of lines) {
                            const length = Number(polyline.dataset.length);
                            polyline.style.strokeDashoffset = String((1 - progress) * length);
                        }
                    }, { duration: duration.enter });
                    break;
                }
                case 'entered': {
                    bgs.concat(lines).forEach(path => {
                        path.style.opacity = '1';
                        path.style.strokeDasharray = '';
                        path.style.strokeDashoffset = '';
                    });
                    break;
                }
                case 'exiting': {
                    for (const polyline of lines) {
                        const length = polyline.getTotalLength();
                        polyline.style.strokeDasharray = String(length);
                        polyline.dataset.length = String(length);
                    }
                    animationControlRef.current = (0, motion_1.animate)(progress => {
                        for (const shape of bgs) {
                            shape.style.opacity = String(1 - progress);
                        }
                        for (const polyline of lines) {
                            const length = Number(polyline.dataset.length);
                            polyline.style.strokeDashoffset = String(progress * length);
                        }
                    }, { duration: duration.exit });
                    break;
                }
            }
        });
        return () => {
            var _a;
            (_a = animationControlRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
            unsubscribe();
        };
    }, [animator]);
    const onRender = (0, react_1.useCallback)(() => {
        var _a;
        if (!animator || !svgRef.current) {
            return;
        }
        const svg = svgRef.current;
        const bgs = Array.from(svg.querySelectorAll('[data-name=bg]'));
        const lines = Array.from(svg.querySelectorAll('[data-name=line]'));
        const isVisible = animator.node.state === animator_1.ANIMATOR_STATES.entering || animator.node.state === animator_1.ANIMATOR_STATES.entered;
        (_a = animationControlRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
        bgs.concat(lines).forEach(path => {
            path.style.opacity = isVisible ? '1' : '0';
            path.style.strokeDasharray = '';
            path.style.strokeDashoffset = '';
        });
    }, [animator]);
    return { onRender };
};
exports.useFrameSVGAssemblingAnimation = useFrameSVGAssemblingAnimation;
