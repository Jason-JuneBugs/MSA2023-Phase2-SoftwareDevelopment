"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Text = exports.TEXT_CLASS = void 0;
const react_1 = require("react");
const react_2 = require("@emotion/react");
const tools_1 = require("@arwes/tools");
const react_tools_1 = require("@arwes/react-tools");
const animator_1 = require("@arwes/animator");
const react_animator_1 = require("@arwes/react-animator");
const text_1 = require("@arwes/text");
const TEXT_CLASS = 'arwes-react-text-text';
exports.TEXT_CLASS = TEXT_CLASS;
const Text = (props) => {
    const { as: asProvided = 'p', className, contentClassName, children, manager, easing, fixed, hideOnExited = true, hideOnEntered, elementRef: elementRefProvided, ...otherProps } = props;
    const as = (0, react_1.useMemo)(() => asProvided, []);
    const [childrenText, setChildrenText] = (0, react_1.useState)('');
    const elementRef = (0, react_1.useRef)(null);
    const contentElementRef = (0, react_1.useRef)(null);
    const transitionControl = (0, react_1.useRef)(null);
    const animator = (0, react_animator_1.useAnimator)();
    const [isExited, setIsExited] = (0, react_1.useState)(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === animator_1.ANIMATOR_STATES.exited);
    const [isEntered, setIsEntered] = (0, react_1.useState)(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === animator_1.ANIMATOR_STATES.entered);
    (0, react_1.useEffect)(() => {
        var _a, _b;
        setChildrenText((_b = (_a = contentElementRef.current) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : '');
    }, [children]);
    (0, react_1.useEffect)(() => {
        if (!animator) {
            if (contentElementRef.current) {
                contentElementRef.current.style.visibility = 'visible';
            }
            return;
        }
        // If there is no text, there is nothing to animate.
        if (!childrenText.length) {
            return;
        }
        if (!fixed) {
            const settings = animator.node.control.getSettings();
            const durationEnter = (0, text_1.getTransitionTextDuration)({
                length: childrenText.length,
                maxDuration: settings.duration.enter
            });
            const durationExit = (0, text_1.getTransitionTextDuration)({
                length: childrenText.length,
                maxDuration: settings.duration.exit
            });
            animator.node.control.setDynamicSettings({
                duration: { enter: durationEnter, exit: durationExit }
            });
        }
        const transitioner = manager === 'decipher'
            ? text_1.transitionTextDecipher
            : text_1.transitionTextSequence;
        const transition = (duration, isEntering) => {
            var _a;
            (_a = transitionControl.current) === null || _a === void 0 ? void 0 : _a.cancel();
            transitionControl.current = transitioner({
                rootElement: elementRef.current,
                contentElement: contentElementRef.current,
                duration,
                isEntering,
                easing,
                hideOnExited,
                hideOnEntered
            });
        };
        const cancelSubscription = animator.node.subscribe(node => {
            setIsEntered(node.state === animator_1.ANIMATOR_STATES.entered);
            setIsExited(node.state === animator_1.ANIMATOR_STATES.exited);
            switch (node.state) {
                case 'entered': {
                    if (!transitionControl.current) {
                        transition(node.duration.enter, true);
                    }
                    break;
                }
                case 'entering': {
                    transition(node.duration.enter, true);
                    break;
                }
                case 'exiting': {
                    transition(node.duration.exit, false);
                    break;
                }
            }
        });
        return () => {
            var _a;
            cancelSubscription();
            (_a = transitionControl.current) === null || _a === void 0 ? void 0 : _a.cancel();
            transitionControl.current = null;
        };
    }, [animator, childrenText]);
    return (0, react_2.jsx)(as, {
        ...otherProps,
        className: (0, tools_1.cx)(TEXT_CLASS, className),
        css: {
            position: 'relative'
        },
        ref: (0, react_tools_1.mergeRefs)(elementRefProvided, elementRef)
    }, (0, react_2.jsx)('span', {
        ref: contentElementRef,
        className: (0, tools_1.cx)(`${TEXT_CLASS}__content`, contentClassName),
        css: {
            position: 'relative',
            zIndex: 1,
            display: 'inline-block',
            visibility: animator && ((hideOnEntered && isEntered) || (hideOnExited && isExited)) ? 'hidden' : 'visible'
        }
    }, children));
};
exports.Text = Text;
