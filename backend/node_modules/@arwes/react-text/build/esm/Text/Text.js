import { useMemo, useState, useRef, useEffect } from 'react';
import { jsx } from '@emotion/react';
import { cx } from '@arwes/tools';
import { mergeRefs } from '@arwes/react-tools';
import { ANIMATOR_STATES as STATES } from '@arwes/animator';
import { useAnimator } from '@arwes/react-animator';
import { getTransitionTextDuration, transitionTextSequence, transitionTextDecipher } from '@arwes/text';
const TEXT_CLASS = 'arwes-react-text-text';
const Text = (props) => {
    const { as: asProvided = 'p', className, contentClassName, children, manager, easing, fixed, hideOnExited = true, hideOnEntered, elementRef: elementRefProvided, ...otherProps } = props;
    const as = useMemo(() => asProvided, []);
    const [childrenText, setChildrenText] = useState('');
    const elementRef = useRef(null);
    const contentElementRef = useRef(null);
    const transitionControl = useRef(null);
    const animator = useAnimator();
    const [isExited, setIsExited] = useState(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === STATES.exited);
    const [isEntered, setIsEntered] = useState(() => (animator === null || animator === void 0 ? void 0 : animator.node.state) === STATES.entered);
    useEffect(() => {
        var _a, _b;
        setChildrenText((_b = (_a = contentElementRef.current) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : '');
    }, [children]);
    useEffect(() => {
        if (!animator) {
            if (contentElementRef.current) {
                contentElementRef.current.style.visibility = 'visible';
            }
            return;
        }
        // If there is no text, there is nothing to animate.
        if (!childrenText.length) {
            return;
        }
        if (!fixed) {
            const settings = animator.node.control.getSettings();
            const durationEnter = getTransitionTextDuration({
                length: childrenText.length,
                maxDuration: settings.duration.enter
            });
            const durationExit = getTransitionTextDuration({
                length: childrenText.length,
                maxDuration: settings.duration.exit
            });
            animator.node.control.setDynamicSettings({
                duration: { enter: durationEnter, exit: durationExit }
            });
        }
        const transitioner = manager === 'decipher'
            ? transitionTextDecipher
            : transitionTextSequence;
        const transition = (duration, isEntering) => {
            var _a;
            (_a = transitionControl.current) === null || _a === void 0 ? void 0 : _a.cancel();
            transitionControl.current = transitioner({
                rootElement: elementRef.current,
                contentElement: contentElementRef.current,
                duration,
                isEntering,
                easing,
                hideOnExited,
                hideOnEntered
            });
        };
        const cancelSubscription = animator.node.subscribe(node => {
            setIsEntered(node.state === STATES.entered);
            setIsExited(node.state === STATES.exited);
            switch (node.state) {
                case 'entered': {
                    if (!transitionControl.current) {
                        transition(node.duration.enter, true);
                    }
                    break;
                }
                case 'entering': {
                    transition(node.duration.enter, true);
                    break;
                }
                case 'exiting': {
                    transition(node.duration.exit, false);
                    break;
                }
            }
        });
        return () => {
            var _a;
            cancelSubscription();
            (_a = transitionControl.current) === null || _a === void 0 ? void 0 : _a.cancel();
            transitionControl.current = null;
        };
    }, [animator, childrenText]);
    return jsx(as, {
        ...otherProps,
        className: cx(TEXT_CLASS, className),
        css: {
            position: 'relative'
        },
        ref: mergeRefs(elementRefProvided, elementRef)
    }, jsx('span', {
        ref: contentElementRef,
        className: cx(`${TEXT_CLASS}__content`, contentClassName),
        css: {
            position: 'relative',
            zIndex: 1,
            display: 'inline-block',
            visibility: animator && ((hideOnEntered && isEntered) || (hideOnExited && isExited)) ? 'hidden' : 'visible'
        }
    }, children));
};
export { TEXT_CLASS, Text };
